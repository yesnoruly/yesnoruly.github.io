{"mappings":"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","sources":["<anon>","node_modules/focus-visible/dist/focus-visible.min.js","node_modules/focus-visible/src/focus-visible.js"],"sourcesContent":["!function(e, t) {\n    \"object\" == typeof exports && \"undefined\" != typeof module ? t() : \"function\" == typeof define && define.amd ? define(t) : t();\n}(0, function() {\n    \"use strict\";\n    function e(e) {\n        var t = !0, n = !1, o = null, d = {\n            text: !0,\n            search: !0,\n            url: !0,\n            tel: !0,\n            email: !0,\n            password: !0,\n            number: !0,\n            date: !0,\n            month: !0,\n            week: !0,\n            time: !0,\n            datetime: !0,\n            \"datetime-local\": !0\n        };\n        function i(e) {\n            return !!(e && e !== document && \"HTML\" !== e.nodeName && \"BODY\" !== e.nodeName && \"classList\" in e && \"contains\" in e.classList);\n        }\n        function s(e) {\n            e.classList.contains(\"focus-visible\") || (e.classList.add(\"focus-visible\"), e.setAttribute(\"data-focus-visible-added\", \"\"));\n        }\n        function u(e) {\n            t = !1;\n        }\n        function a() {\n            document.addEventListener(\"mousemove\", c), document.addEventListener(\"mousedown\", c), document.addEventListener(\"mouseup\", c), document.addEventListener(\"pointermove\", c), document.addEventListener(\"pointerdown\", c), document.addEventListener(\"pointerup\", c), document.addEventListener(\"touchmove\", c), document.addEventListener(\"touchstart\", c), document.addEventListener(\"touchend\", c);\n        }\n        function c(e) {\n            e.target.nodeName && \"html\" === e.target.nodeName.toLowerCase() || (t = !1, document.removeEventListener(\"mousemove\", c), document.removeEventListener(\"mousedown\", c), document.removeEventListener(\"mouseup\", c), document.removeEventListener(\"pointermove\", c), document.removeEventListener(\"pointerdown\", c), document.removeEventListener(\"pointerup\", c), document.removeEventListener(\"touchmove\", c), document.removeEventListener(\"touchstart\", c), document.removeEventListener(\"touchend\", c));\n        }\n        document.addEventListener(\"keydown\", function(n) {\n            n.metaKey || n.altKey || n.ctrlKey || (i(e.activeElement) && s(e.activeElement), t = !0);\n        }, !0), document.addEventListener(\"mousedown\", u, !0), document.addEventListener(\"pointerdown\", u, !0), document.addEventListener(\"touchstart\", u, !0), document.addEventListener(\"visibilitychange\", function(e) {\n            \"hidden\" === document.visibilityState && (n && (t = !0), a());\n        }, !0), a(), e.addEventListener(\"focus\", function(e) {\n            var n, o, u;\n            i(e.target) && (t || (n = e.target, o = n.type, \"INPUT\" === (u = n.tagName) && d[o] && !n.readOnly || \"TEXTAREA\" === u && !n.readOnly || n.isContentEditable)) && s(e.target);\n        }, !0), e.addEventListener(\"blur\", function(e) {\n            var t;\n            i(e.target) && (e.target.classList.contains(\"focus-visible\") || e.target.hasAttribute(\"data-focus-visible-added\")) && (n = !0, window.clearTimeout(o), o = window.setTimeout(function() {\n                n = !1;\n            }, 100), (t = e.target).hasAttribute(\"data-focus-visible-added\") && (t.classList.remove(\"focus-visible\"), t.removeAttribute(\"data-focus-visible-added\")));\n        }, !0), e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && e.host ? e.host.setAttribute(\"data-js-focus-visible\", \"\") : e.nodeType === Node.DOCUMENT_NODE && (document.documentElement.classList.add(\"js-focus-visible\"), document.documentElement.setAttribute(\"data-js-focus-visible\", \"\"));\n    }\n    if (\"undefined\" != typeof window && \"undefined\" != typeof document) {\n        var t;\n        window.applyFocusVisiblePolyfill = e;\n        try {\n            t = new CustomEvent(\"focus-visible-polyfill-ready\");\n        } catch (e) {\n            (t = document.createEvent(\"CustomEvent\")).initCustomEvent(\"focus-visible-polyfill-ready\", !1, !1, {});\n        }\n        window.dispatchEvent(t);\n    }\n    \"undefined\" != typeof document && e(document);\n});\n\n//# sourceMappingURL=index.f6ede4f9.js.map\n","!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t():\"function\"==typeof define&&define.amd?define(t):t()}(0,function(){\"use strict\";function e(e){var t=!0,n=!1,o=null,d={text:!0,search:!0,url:!0,tel:!0,email:!0,password:!0,number:!0,date:!0,month:!0,week:!0,time:!0,datetime:!0,\"datetime-local\":!0};function i(e){return!!(e&&e!==document&&\"HTML\"!==e.nodeName&&\"BODY\"!==e.nodeName&&\"classList\"in e&&\"contains\"in e.classList)}function s(e){e.classList.contains(\"focus-visible\")||(e.classList.add(\"focus-visible\"),e.setAttribute(\"data-focus-visible-added\",\"\"))}function u(e){t=!1}function a(){document.addEventListener(\"mousemove\",c),document.addEventListener(\"mousedown\",c),document.addEventListener(\"mouseup\",c),document.addEventListener(\"pointermove\",c),document.addEventListener(\"pointerdown\",c),document.addEventListener(\"pointerup\",c),document.addEventListener(\"touchmove\",c),document.addEventListener(\"touchstart\",c),document.addEventListener(\"touchend\",c)}function c(e){e.target.nodeName&&\"html\"===e.target.nodeName.toLowerCase()||(t=!1,document.removeEventListener(\"mousemove\",c),document.removeEventListener(\"mousedown\",c),document.removeEventListener(\"mouseup\",c),document.removeEventListener(\"pointermove\",c),document.removeEventListener(\"pointerdown\",c),document.removeEventListener(\"pointerup\",c),document.removeEventListener(\"touchmove\",c),document.removeEventListener(\"touchstart\",c),document.removeEventListener(\"touchend\",c))}document.addEventListener(\"keydown\",function(n){n.metaKey||n.altKey||n.ctrlKey||(i(e.activeElement)&&s(e.activeElement),t=!0)},!0),document.addEventListener(\"mousedown\",u,!0),document.addEventListener(\"pointerdown\",u,!0),document.addEventListener(\"touchstart\",u,!0),document.addEventListener(\"visibilitychange\",function(e){\"hidden\"===document.visibilityState&&(n&&(t=!0),a())},!0),a(),e.addEventListener(\"focus\",function(e){var n,o,u;i(e.target)&&(t||(n=e.target,o=n.type,\"INPUT\"===(u=n.tagName)&&d[o]&&!n.readOnly||\"TEXTAREA\"===u&&!n.readOnly||n.isContentEditable))&&s(e.target)},!0),e.addEventListener(\"blur\",function(e){var t;i(e.target)&&(e.target.classList.contains(\"focus-visible\")||e.target.hasAttribute(\"data-focus-visible-added\"))&&(n=!0,window.clearTimeout(o),o=window.setTimeout(function(){n=!1},100),(t=e.target).hasAttribute(\"data-focus-visible-added\")&&(t.classList.remove(\"focus-visible\"),t.removeAttribute(\"data-focus-visible-added\")))},!0),e.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&e.host?e.host.setAttribute(\"data-js-focus-visible\",\"\"):e.nodeType===Node.DOCUMENT_NODE&&(document.documentElement.classList.add(\"js-focus-visible\"),document.documentElement.setAttribute(\"data-js-focus-visible\",\"\"))}if(\"undefined\"!=typeof window&&\"undefined\"!=typeof document){var t;window.applyFocusVisiblePolyfill=e;try{t=new CustomEvent(\"focus-visible-polyfill-ready\")}catch(e){(t=document.createEvent(\"CustomEvent\")).initCustomEvent(\"focus-visible-polyfill-ready\",!1,!1,{})}window.dispatchEvent(t)}\"undefined\"!=typeof document&&e(document)});\n//# sourceMappingURL=focus-visible.min.js.map\n","/**\n * Applies the :focus-visible polyfill at the given scope.\n * A scope in this case is either the top-level Document or a Shadow Root.\n *\n * @param {(Document|ShadowRoot)} scope\n * @see https://github.com/WICG/focus-visible\n */\nfunction applyFocusVisiblePolyfill(scope) {\n  var hadKeyboardEvent = true;\n  var hadFocusVisibleRecently = false;\n  var hadFocusVisibleRecentlyTimeout = null;\n\n  var inputTypesAllowlist = {\n    text: true,\n    search: true,\n    url: true,\n    tel: true,\n    email: true,\n    password: true,\n    number: true,\n    date: true,\n    month: true,\n    week: true,\n    time: true,\n    datetime: true,\n    'datetime-local': true\n  };\n\n  /**\n   * Helper function for legacy browsers and iframes which sometimes focus\n   * elements like document, body, and non-interactive SVG.\n   * @param {Element} el\n   */\n  function isValidFocusTarget(el) {\n    if (\n      el &&\n      el !== document &&\n      el.nodeName !== 'HTML' &&\n      el.nodeName !== 'BODY' &&\n      'classList' in el &&\n      'contains' in el.classList\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Computes whether the given element should automatically trigger the\n   * `focus-visible` class being added, i.e. whether it should always match\n   * `:focus-visible` when focused.\n   * @param {Element} el\n   * @return {boolean}\n   */\n  function focusTriggersKeyboardModality(el) {\n    var type = el.type;\n    var tagName = el.tagName;\n\n    if (tagName === 'INPUT' && inputTypesAllowlist[type] && !el.readOnly) {\n      return true;\n    }\n\n    if (tagName === 'TEXTAREA' && !el.readOnly) {\n      return true;\n    }\n\n    if (el.isContentEditable) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Add the `focus-visible` class to the given element if it was not added by\n   * the author.\n   * @param {Element} el\n   */\n  function addFocusVisibleClass(el) {\n    if (el.classList.contains('focus-visible')) {\n      return;\n    }\n    el.classList.add('focus-visible');\n    el.setAttribute('data-focus-visible-added', '');\n  }\n\n  /**\n   * Remove the `focus-visible` class from the given element if it was not\n   * originally added by the author.\n   * @param {Element} el\n   */\n  function removeFocusVisibleClass(el) {\n    if (!el.hasAttribute('data-focus-visible-added')) {\n      return;\n    }\n    el.classList.remove('focus-visible');\n    el.removeAttribute('data-focus-visible-added');\n  }\n\n  /**\n   * If the most recent user interaction was via the keyboard;\n   * and the key press did not include a meta, alt/option, or control key;\n   * then the modality is keyboard. Otherwise, the modality is not keyboard.\n   * Apply `focus-visible` to any current active element and keep track\n   * of our keyboard modality state with `hadKeyboardEvent`.\n   * @param {KeyboardEvent} e\n   */\n  function onKeyDown(e) {\n    if (e.metaKey || e.altKey || e.ctrlKey) {\n      return;\n    }\n\n    if (isValidFocusTarget(scope.activeElement)) {\n      addFocusVisibleClass(scope.activeElement);\n    }\n\n    hadKeyboardEvent = true;\n  }\n\n  /**\n   * If at any point a user clicks with a pointing device, ensure that we change\n   * the modality away from keyboard.\n   * This avoids the situation where a user presses a key on an already focused\n   * element, and then clicks on a different element, focusing it with a\n   * pointing device, while we still think we're in keyboard modality.\n   * @param {Event} e\n   */\n  function onPointerDown(e) {\n    hadKeyboardEvent = false;\n  }\n\n  /**\n   * On `focus`, add the `focus-visible` class to the target if:\n   * - the target received focus as a result of keyboard navigation, or\n   * - the event target is an element that will likely require interaction\n   *   via the keyboard (e.g. a text box)\n   * @param {Event} e\n   */\n  function onFocus(e) {\n    // Prevent IE from focusing the document or HTML element.\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n\n    if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {\n      addFocusVisibleClass(e.target);\n    }\n  }\n\n  /**\n   * On `blur`, remove the `focus-visible` class from the target.\n   * @param {Event} e\n   */\n  function onBlur(e) {\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n\n    if (\n      e.target.classList.contains('focus-visible') ||\n      e.target.hasAttribute('data-focus-visible-added')\n    ) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      hadFocusVisibleRecentlyTimeout = window.setTimeout(function() {\n        hadFocusVisibleRecently = false;\n      }, 100);\n      removeFocusVisibleClass(e.target);\n    }\n  }\n\n  /**\n   * If the user changes tabs, keep track of whether or not the previously\n   * focused element had .focus-visible.\n   * @param {Event} e\n   */\n  function onVisibilityChange(e) {\n    if (document.visibilityState === 'hidden') {\n      // If the tab becomes active again, the browser will handle calling focus\n      // on the element (Safari actually calls it twice).\n      // If this tab change caused a blur on an element with focus-visible,\n      // re-apply the class when the user switches back to the tab.\n      if (hadFocusVisibleRecently) {\n        hadKeyboardEvent = true;\n      }\n      addInitialPointerMoveListeners();\n    }\n  }\n\n  /**\n   * Add a group of listeners to detect usage of any pointing devices.\n   * These listeners will be added when the polyfill first loads, and anytime\n   * the window is blurred, so that they are active when the window regains\n   * focus.\n   */\n  function addInitialPointerMoveListeners() {\n    document.addEventListener('mousemove', onInitialPointerMove);\n    document.addEventListener('mousedown', onInitialPointerMove);\n    document.addEventListener('mouseup', onInitialPointerMove);\n    document.addEventListener('pointermove', onInitialPointerMove);\n    document.addEventListener('pointerdown', onInitialPointerMove);\n    document.addEventListener('pointerup', onInitialPointerMove);\n    document.addEventListener('touchmove', onInitialPointerMove);\n    document.addEventListener('touchstart', onInitialPointerMove);\n    document.addEventListener('touchend', onInitialPointerMove);\n  }\n\n  function removeInitialPointerMoveListeners() {\n    document.removeEventListener('mousemove', onInitialPointerMove);\n    document.removeEventListener('mousedown', onInitialPointerMove);\n    document.removeEventListener('mouseup', onInitialPointerMove);\n    document.removeEventListener('pointermove', onInitialPointerMove);\n    document.removeEventListener('pointerdown', onInitialPointerMove);\n    document.removeEventListener('pointerup', onInitialPointerMove);\n    document.removeEventListener('touchmove', onInitialPointerMove);\n    document.removeEventListener('touchstart', onInitialPointerMove);\n    document.removeEventListener('touchend', onInitialPointerMove);\n  }\n\n  /**\n   * When the polfyill first loads, assume the user is in keyboard modality.\n   * If any event is received from a pointing device (e.g. mouse, pointer,\n   * touch), turn off keyboard modality.\n   * This accounts for situations where focus enters the page from the URL bar.\n   * @param {Event} e\n   */\n  function onInitialPointerMove(e) {\n    // Work around a Safari quirk that fires a mousemove on <html> whenever the\n    // window blurs, even if you're tabbing out of the page. ¯\\_(ツ)_/¯\n    if (e.target.nodeName && e.target.nodeName.toLowerCase() === 'html') {\n      return;\n    }\n\n    hadKeyboardEvent = false;\n    removeInitialPointerMoveListeners();\n  }\n\n  // For some kinds of state, we are interested in changes at the global scope\n  // only. For example, global pointer input, global key presses and global\n  // visibility change should affect the state at every scope:\n  document.addEventListener('keydown', onKeyDown, true);\n  document.addEventListener('mousedown', onPointerDown, true);\n  document.addEventListener('pointerdown', onPointerDown, true);\n  document.addEventListener('touchstart', onPointerDown, true);\n  document.addEventListener('visibilitychange', onVisibilityChange, true);\n\n  addInitialPointerMoveListeners();\n\n  // For focus and blur, we specifically care about state changes in the local\n  // scope. This is because focus / blur events that originate from within a\n  // shadow root are not re-dispatched from the host element if it was already\n  // the active element in its own scope:\n  scope.addEventListener('focus', onFocus, true);\n  scope.addEventListener('blur', onBlur, true);\n\n  // We detect that a node is a ShadowRoot by ensuring that it is a\n  // DocumentFragment and also has a host property. This check covers native\n  // implementation and polyfill implementation transparently. If we only cared\n  // about the native implementation, we could just check if the scope was\n  // an instance of a ShadowRoot.\n  if (scope.nodeType === Node.DOCUMENT_FRAGMENT_NODE && scope.host) {\n    // Since a ShadowRoot is a special kind of DocumentFragment, it does not\n    // have a root element to add a class to. So, we add this attribute to the\n    // host element instead:\n    scope.host.setAttribute('data-js-focus-visible', '');\n  } else if (scope.nodeType === Node.DOCUMENT_NODE) {\n    document.documentElement.classList.add('js-focus-visible');\n    document.documentElement.setAttribute('data-js-focus-visible', '');\n  }\n}\n\n// It is important to wrap all references to global window and document in\n// these checks to support server-side rendering use cases\n// @see https://github.com/WICG/focus-visible/issues/199\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  // Make the polyfill helper globally available. This can be used as a signal\n  // to interested libraries that wish to coordinate with the polyfill for e.g.,\n  // applying the polyfill to a shadow root:\n  window.applyFocusVisiblePolyfill = applyFocusVisiblePolyfill;\n\n  // Notify interested libraries of the polyfill's presence, in case the\n  // polyfill was loaded lazily:\n  var event;\n\n  try {\n    event = new CustomEvent('focus-visible-polyfill-ready');\n  } catch (error) {\n    // IE11 does not support using CustomEvent as a constructor directly:\n    event = document.createEvent('CustomEvent');\n    event.initCustomEvent('focus-visible-polyfill-ready', false, false, {});\n  }\n\n  window.dispatchEvent(event);\n}\n\nif (typeof document !== 'undefined') {\n  // Apply the polyfill to the global document, so that no JavaScript\n  // coordination is required to use the polyfill in the top-level document:\n  applyFocusVisiblePolyfill(document);\n}\n"],"names":["t","e","n","o","d","text","search","url","tel","email","password","number","date","month","week","time","datetime","i","document","nodeName","classList","s","contains","add","setAttribute","u","a","addEventListener","c","target","toLowerCase","removeEventListener","metaKey","altKey","ctrlKey","activeElement","visibilityState","type","tagName","readOnly","isContentEditable","hasAttribute","window","clearTimeout","setTimeout","remove","removeAttribute","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","DOCUMENT_NODE","documentElement","applyFocusVisiblePolyfill","CustomEvent","createEvent","initCustomEvent","dispatchEvent","exports","module","define","amd","scope","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesAllowlist","datetime-local","isValidFocusTarget","el","addFocusVisibleClass","onPointerDown","addInitialPointerMoveListeners","onInitialPointerMove","event","error"],"version":3,"file":"index.f6ede4f9.js.map"}